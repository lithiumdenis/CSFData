%%% Распознавание образов, описываемых Гауссовскими
% распределениями c различными матрицами ковариации
clear all;
close all;
%% 1. Задание параметров и генерация образов
% 1.1 Параметры генерации
n=2;                % размерность пространства признаков
M=3;                % число классов
Nn=[100; 100; 100]; % число образов 1-го, 2-го, 3-го классов...
N=sum(Nn);          % соответственно, а так же общее число образов
pw=Nn/N;            % априорные вероятности появления классов
% 1.2. Параметры классов
m=cell(1, M);       % инициализация массивов ячеек для мат. ожиданий,...
C=cell(1, M);       % ковариационных матриц,...
x=cell(1, M);       % и массивов образов
m{1}=[2; 1];        % задание средних значений классов
m{2}=[-1; 4];
m{3}=[4; -5];
C{1}=[3 -1; -1 3];  % задание матриц ковариации классов
C{2}=[5 1; 1 4];
C{3}=[4 0.5; 0.5 3];
% 1.3. Генерация образов классов
for i=1:M
    x{i}=repmat(m{i}, [1, Nn(i)])+randncor(n, Nn(i), C{i});
end;
Xn=[x{1}, x{2}, x{3}];	% общая выборка образов
% 1.4. Визуализация образов
L1=zeros(1, Nn(1));     % метки классов для функции plotpv
L2=0.5*ones(1, Nn(2));
L3=ones(1, Nn(3));
Ln=[L1, L2, L3];        % общий массив меток
figure; plotpv(Xn, Ln);	% визуализация образов
title('Исходное расположение образов');
%% 2. Классификация образов
% 2.1. Вычисление значений разделяющей функции (формула (4))
dC=cell(1, M);	% массив ячеек для определителей ков. матриц
g=zeros(M, N);  % и массива значений разделяющих функций
for i=1:M
    dC{i}=det(C{i});    % вычисление определителей ков. матриц
end;
for k=1:N
    xk=Xn(:, k);    % для каждого образа из общей выборки...
    for i=1:M       % вычисление значений разделяющих функций
        g(i, k)=-0.5*(log(dC{i})+(xk-m{i})'/C{i}*(xk-m{i}))+log(pw(i));
    end;
end;
% 2.2. Получение индексов классов (cls_idx), соответствующих...
[vals, cls_idx]=max(g); % максимуму разделяющей функции (формула (2))
Lg=(cls_idx-1)./(M-1);  % значения меток (в диапазоне [0, 1])
figure; plotpv(Xn, Lg); % визуализация классифицированных образов
title('Результаты классификации');
%% 3. Расчет вероятностей ошибок распознавания
Pt=zeros(M);        % матрица значений ошибок
E=eye(n);           % единичная матрица
% 3.1. Заполнение НЕдиагональных элементов матрицы...
% т.е. вероятностей ошибок распознавания
% (ошибки 1-го и 2-го рода для разных классов могут совпадать)
%       ( p1     alf12  alf13 )   (  p1    bet21  bet31 )
% Pt =  ( alf21   p2    alf23 ) = ( bet12   p2    bet32 ),
%       ( alf31  alf32    p3  )   ( bet13  bet23    p3  )
% где pi - вероятность верного распознавания образов i-го класса;
%   alfij - вероятность ошибки 1-го рода для i-го класса при
%           предъявлении образов j-го класса;
%   betij - вероятность ошибки 2-го рода для i-го класса при
%           предъявлении образов j-го класса;
for i=1:M-1             % попарное сравнение классов
    for j=i+1:M
        % 3.2. Вычисление параметров по формуле (9)
        dm=m{i}-m{j};           % вектор разности мат. ожиданий
        l0_=log(pw(j)/pw(i));   % порог принятия решения
        tr_ij=trace(C{i}/C{j}-E);   % следы матриц
        tr_ji=trace(E-C{j}/C{i});
        mg_i=0.5*(tr_ij+dm'/C{j}*dm-log(dC{i}/dC{j}));
        Dg_i=0.5*(tr_ij^2+dm'/C{j}*C{i}/C{j}*dm);
        mg_j=0.5*(tr_ji-dm'/C{i}*dm+log(dC{j}/dC{i}));
        Dg_j=0.5*(tr_ji^2+dm'/C{i}*C{j}/C{i}*dm);
        % 3.3. Вычисление ошибок 1-го и 2-го рода для образов...
        % i-го класса при предъявлении образов j-го класса
        alf_ij=normcdf(l0_, mg_i, sqrt(Dg_i));	% по формуле (5)
        bet_ij=1-normcdf(l0_, mg_j, sqrt(Dg_j));% от l0' до +infinity
        Pt(i, j)=alf_ij;    % запоминаем их...
        Pt(j, i)=bet_ij;    % в матрице ошибок
    end;
end;
% 3.4. Вычисление вероятностей правильного распознавания как
% (1 - сумма_элементов_строки_матрицы_ошибок)
Pt=Pt+diag(1-sum(Pt, 2));   % размещение диагональных элементов
disp('Теоретическая матрица вероятностей ошибок');
disp(Pt);       % вывод на консоль матрицы ошибок
%% 4. Экспериментальное вычисление матрицы вероятностей ошибок
% 4.1. Определение результатов классификации для образов
x1_labs=cls_idx(1:Nn(1));               % 1-го класса
x2_labs=cls_idx(Nn(1)+(1:Nn(2)));       % 2-го класса
x3_labs=cls_idx(N-Nn(3)+(1:Nn(3))); % 3-го класса
% 4.2. Метки образов 1-го класса, отнесённые к:
labs_1=x1_labs==1;      % 1-му классу (верно)
labs_12=x1_labs==2;     % 2-му классу
labs_13=x1_labs==3;     % 3-му классу
% 4.3. Метки образов 2-го класса, отнесённые к:
labs_2=x2_labs==2;      % 2-му классу (верно)
labs_21=x2_labs==1;     % 1-му классу
labs_23=x2_labs==3;     % 3-му классу
% 4.4. Метки образов 3-го класса, отнесённые к:
labs_3=x3_labs==3;      % 3-му классу (верно)
labs_31=x3_labs==1;     % 1-му классу
labs_32=x3_labs==2;     % 2-му классу
% 4.5. Формирование экспериментальной матрицы вероятностей ошибок
Pp=[sum(labs_1)/Nn(1)	sum(labs_12)/Nn(1)	sum(labs_13)/Nn(1);
    sum(labs_21)/Nn(2)	sum(labs_2)/Nn(2)	sum(labs_23)/Nn(2);
    sum(labs_31)/Nn(3)  sum(labs_32)/Nn(3)  sum(labs_3)/Nn(3) ];
disp('Экспериментальная матрица вероятностей ошибок');
disp(Pp);       % вывод на консоль матрицы ошибок (должна быть близкой к Pt)
