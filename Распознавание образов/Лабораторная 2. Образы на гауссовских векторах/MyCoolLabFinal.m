clc; clear;
%% Часть 1: Генерация объектов 2х классов
n=2;             % размерность пространства признаков
M=2;             % число классов
N1=150;          % число объектов каждого 1 класса
N2=200;          % число объектов каждого 2 класса
m1=[2; -3];      % средние значения классов       
m2=[1; 10];      % средние значения классов
C=[3 -1; -1 4];  % матрица ковариации
x1=repmat(m1, [1, N1]) + randncor(n, N1, C);  % Генерация образов 1-го класса
x2=repmat(m2, [1, N2]) + randncor(n, N2, C);  % Генерация образов 2-го класса
X=[x1, x2];                                 % общая выборка образов
T=[true(1, N1), false(1, N2)];              % метки классов для функции plotpv
N=N1+N2;                                    % общее число объектов
pw1=N1/N;   pw2=N2/N;                       % априорные вероятности появления классов
plotpv(X, T);                               % визуализация образов исходного расположения объектов
title('Исходное расположение объектов');
%% Часть 2: Классификация образов
g=false(1, N);      % массив ячеек для значений разделяющей функции
l0_=log(pw2/pw1);   % отношение правдоподобия
for i=1:N
    % для каждого образа из общей выборки
    xi=X(:, i); 
    % вычисление значений разделяющих функций по формуле 6
    g(i)=xi'/C*(m1-m2)-0.5*(m1+m2)'/C*(m1-m2)>l0_; 
end;
figure;
plotpv(X, g);  % визуализация классифицированных образов
title('Результаты классификации');
%% Часть 3: Вычисление ошибок 1-го и 2-го рода для образов
mg1=0.5*(m1-m2)'* C^(-1)* (m1-m2); %Вычисление соотношений по формулам 7
mg2=-mg1;
Dg=2*mg1;
% Вычисление ошибок 1-го и 2-го рода по формуле 5
alpha=normcdf(l0_, mg1, sqrt(Dg));  % от -infinity до l_0'
beta=1-normcdf(l0_, mg2, sqrt(Dg)); % от l_0' до +infinity
fprintf(1,'alpha = %g \n', alpha);
fprintf(1,'beta = %g \n', beta);